import {
  Injectable,
  Logger,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Workspace } from '../../../shared/database/entities/workspace.entity';
import { WorkspaceSessionEntity } from '../../../shared/database/entities/session.entity';
import { WorkspaceDatabaseService } from '../../../shared/database/services/workspace.service';
import { WorkspacePersistenceService } from './persistence/workspace-persistence.service';
import { WorkspaceDeleteService } from './workspace-delete.service';
import { UpdateWorkspaceDto } from '../dto/workspace.dto';
import { ListWorkspacesQueryDto } from '../dto/workspace.dto';
import { CreateWorkspaceDto, SaveWorkspaceDto } from '../dto/workspace.dto';
import type {
  Workspace as IWorkspace,
  WorkspaceResponse,
  WorkspaceListResponse,
  SaveWorkspaceResponse,
  CreateWorkspaceRequest,
  UpdateWorkspaceRequest,
  WorkspaceWithSession,
} from '@sansa-dev/shared';

/**
 * Workspace Service
 *
 * Handles all operations related to persistent workspace entities.
 * This service manages the lifecycle of workspaces (persistent user projects)
 * and coordinates with session management for workspace operations.
 *
 * Key responsibilities:
 * - Create, read, update, delete persistent workspaces
 * - List user's workspaces with session information
 * - Save workspace data from active sessions
 * - Validate workspace ownership and existence
 * - Coordinate with session management for workspace operations
 */
@Injectable()
export class WorkspaceService {
  private readonly logger = new Logger(WorkspaceService.name);

  constructor(
    @InjectRepository(WorkspaceSessionEntity)
    private readonly workspaceSessionRepository: Repository<WorkspaceSessionEntity>,
    private readonly workspaceDbService: WorkspaceDatabaseService,
    private readonly persistenceService: WorkspacePersistenceService,
    private readonly workspaceDeleteService: WorkspaceDeleteService,
  ) {}

  /**
   * Create a new persistent workspace from a template
   *
   * This creates a new workspace entity, initializes it with a template,
   * creates an initial session, and saves the templated workspace as an archive.
   * This is the "Create New Workspace" workflow.
   *
   * @param userId - User creating the workspace
   * @param createDto - Workspace creation parameters
   * @returns Created workspace with metadata
   */
  async createWorkspace(
    userId: string,
    createDto: CreateWorkspaceDto,
  ): Promise<WorkspaceResponse> {
    this.logger.log(
      `Creating workspace for user ${userId}: ${createDto.name || 'Unnamed'}`,
    );

    try {
      // Generate storage key for the workspace
      const storageKey = this.generateStorageKey(userId, createDto.templateId);

      // Get default resource allocation and environment
      const defaultResources = this.getDefaultResourceAllocation();
      const defaultEnvironment = this.getDefaultEnvironment();

      // Create workspace entity (ID will be generated by database)
      const workspace = await this.workspaceDbService.create({
        userId,
        name: createDto.name,
        templateId: createDto.templateId || 'base',
        storageKey,
        resources: defaultResources,
        environment: defaultEnvironment,
        createdAt: new Date().toISOString(),
        lastAccessedAt: new Date().toISOString(),
        metadata: {
          templateVersion: '1.0.0',
          createdFromTemplate: createDto.templateId || 'base',
        },
      });

      this.logger.log(`Created workspace ${workspace.id} for user ${userId}`);

      return {
        workspace: this.mapWorkspaceEntityToInterface(workspace),
      };
    } catch (error) {
      this.logger.error(`Failed to create workspace for user ${userId}`, error);
      throw new BadRequestException('Failed to create workspace');
    }
  }

  /**
   * Get workspace by ID with ownership validation
   *
   * @param workspaceId - Workspace ID to retrieve
   * @param userId - User requesting the workspace
   * @returns Workspace entity
   * @throws NotFoundException if workspace not found or not owned by user
   */
  async getWorkspace(workspaceId: string, userId: string): Promise<IWorkspace> {
    const workspace = await this.workspaceDbService.findByIdAndUser(
      workspaceId,
      userId,
    );

    return this.mapWorkspaceEntityToInterface(workspace);
  }

  /**
   * List user's workspaces with optional filtering and pagination
   *
   * @param userId - User whose workspaces to list
   * @param query - Query parameters for filtering and pagination
   * @returns Paginated list of workspaces with session information
   */
  async listWorkspaces(
    userId: string,
    query: ListWorkspacesQueryDto,
  ): Promise<WorkspaceListResponse> {
    this.logger.debug(`Listing workspaces for user ${userId}`);

    try {
      // Build query options
      const queryOptions = {
        limit: query.limit || 50,
        offset: query.offset || 0,
        orderBy: query.orderBy || 'lastAccessedAt',
        orderDirection: query.orderDirection || 'DESC',
      };

      // Get workspaces from database
      const workspaces = await this.workspaceDbService.findByUser(
        userId,
        queryOptions,
      );

      // Get session information for each workspace
      const workspacesWithSessions = await Promise.all(
        workspaces.map((workspace) =>
          this.enrichWorkspaceWithSessionInfo(workspace),
        ),
      );

      // Apply additional filtering
      let filteredWorkspaces = workspacesWithSessions;

      if (query.templateId) {
        filteredWorkspaces = filteredWorkspaces.filter(
          (w) => w.templateId === query.templateId,
        );
      }

      if (query.search) {
        const searchTerm = query.search.toLowerCase();
        filteredWorkspaces = filteredWorkspaces.filter((w) =>
          w.name?.toLowerCase().includes(searchTerm),
        );
      }

      const total = await this.workspaceDbService.countByUser(userId);

      return {
        workspaces: filteredWorkspaces,
        total,
      };
    } catch (error) {
      this.logger.error(`Failed to list workspaces for user ${userId}`, error);
      throw new BadRequestException('Failed to retrieve workspaces');
    }
  }

  /**
   * Update workspace metadata
   *
   * @param workspaceId - Workspace ID to update
   * @param userId - User owning the workspace
   * @param updateDto - Update parameters
   * @returns Updated workspace
   */
  async updateWorkspace(
    workspaceId: string,
    userId: string,
    updateDto: UpdateWorkspaceDto,
  ): Promise<WorkspaceResponse> {
    this.logger.log(`Updating workspace ${workspaceId} for user ${userId}`);

    // Validate workspace exists and user owns it
    const existingWorkspace = await this.workspaceDbService.findByIdAndUser(
      workspaceId,
      userId,
    );

    try {
      const updatedWorkspace = await this.workspaceDbService.update(
        workspaceId,
        {
          name: updateDto.name,
          lastAccessedAt: new Date().toISOString(),
        },
      );

      this.logger.log(`Updated workspace ${workspaceId}`);

      return {
        workspace: this.mapWorkspaceEntityToInterface(updatedWorkspace),
      };
    } catch (error) {
      this.logger.error(`Failed to update workspace ${workspaceId}`, error);
      throw new BadRequestException('Failed to update workspace');
    }
  }

  /**
   * Delete workspace and all associated resources
   *
   * This method delegates to the comprehensive WorkspaceDeleteService
   * which handles the complete cleanup pipeline including:
   * - Session cleanup (containers, database records)
   * - Storage cleanup (workspace archives)
   * - Context data cleanup (brand images, assets, etc.)
   * - Database cleanup with proper error handling and rollback
   *
   * @param workspaceId - Workspace ID to delete
   * @param userId - User owning the workspace
   */
  async deleteWorkspace(workspaceId: string, userId: string): Promise<void> {
    return this.workspaceDeleteService.deleteWorkspace(workspaceId, userId);
  }

  /**
   * Save workspace data from active session
   *
   * Finds the active session for the workspace and saves its current state.
   *
   * @param workspaceId - Workspace ID to save
   * @param userId - User owning the workspace
   * @param saveDto - Save parameters
   * @returns Save operation result
   */
  async saveWorkspace(
    saveDto: SaveWorkspaceDto,
    userId: string,
  ): Promise<SaveWorkspaceResponse> {
    const { workspaceId } = saveDto;

    this.logger.log(`Saving workspace ${workspaceId} for user ${userId}`);

    try {
      // Find active session for this workspace
      const activeSession = await this.findActiveSessionForWorkspace(
        workspaceId,
        userId,
      );

      if (!activeSession) {
        throw new BadRequestException(
          'No active session found for workspace. Please open the workspace first.',
        );
      }

      // Save workspace data using persistence service
      const saveResult = await this.persistenceService.saveWorkspaceArchive({
        sessionId: activeSession.id,
        userId: activeSession.userId,
        workspaceId: activeSession.workspaceId,
        containerId: activeSession.containerId,
      });

      // Update workspace last saved timestamp
      await this.workspaceDbService.updateLastSaved(workspaceId);

      // Update session last saved timestamp
      activeSession.lastSavedAt = new Date().toISOString();
      await this.workspaceSessionRepository.save(activeSession);

      this.logger.log(
        `Saved workspace ${workspaceId} from session ${activeSession.id}`,
      );

      return saveResult;
    } catch (error) {
      if (error instanceof BadRequestException) {
        throw error;
      }

      this.logger.error(`Failed to save workspace ${workspaceId}`, error);
      throw new BadRequestException('Failed to save workspace');
    }
  }

  /**
   * Find active session for a workspace
   *
   * @param workspaceId - Workspace ID
   * @param userId - User ID for security validation
   * @returns Active session or null if none found
   */
  private async findActiveSessionForWorkspace(
    workspaceId: string,
    userId: string,
  ): Promise<WorkspaceSessionEntity | null> {
    const session = await this.workspaceSessionRepository.findOne({
      where: {
        workspaceId,
        userId,
        status: 'running',
      },
      order: {
        createdAt: 'DESC',
      },
    });

    return session;
  }

  /**
   * Enrich workspace with session information
   *
   * @param workspace - Workspace entity
   * @returns Workspace with session information
   */
  private async enrichWorkspaceWithSessionInfo(
    workspace: Workspace,
  ): Promise<WorkspaceWithSession> {
    const activeSession = await this.findActiveSessionForWorkspace(
      workspace.id,
      workspace.userId,
    );

    const workspaceWithSession: WorkspaceWithSession = {
      ...this.mapWorkspaceEntityToInterface(workspace),
      activeSessionId: activeSession?.id || undefined,
      hasActiveSession: !!activeSession,
      sessionStatus: activeSession?.status || undefined,
    };

    return workspaceWithSession;
  }

  /**
   * Map workspace entity to interface type
   *
   * @param entity - Workspace entity
   * @returns Workspace interface
   */
  private mapWorkspaceEntityToInterface(entity: Workspace): IWorkspace {
    return {
      id: entity.id,
      userId: entity.userId,
      name: entity.name || undefined,
      templateId: entity.templateId,
      storageKey: entity.storageKey,
      createdAt: entity.createdAt,
      lastAccessedAt: entity.lastAccessedAt,
      lastSavedAt: entity.lastSavedAt || undefined,
      metadata: entity.metadata || undefined,
    };
  }

  /**
   * Generate storage key for workspace
   *
   * @param userId - User ID
   * @param templateId - Template ID
   * @returns Storage key string
   */
  private generateStorageKey(userId: string, templateId: string): string {
    const timestamp = Date.now();
    return `/workspaces/${userId}/${templateId}/${timestamp}`;
  }

  /**
   * Get default resource allocation for new workspaces
   *
   * @returns Default resource allocation
   */
  private getDefaultResourceAllocation() {
    return {
      cpu: 0.5,
      memory: 512,
      storage: 1024,
      networkBandwidth: 10,
    };
  }

  /**
   * Get default environment configuration for new workspaces
   *
   * @returns Default environment configuration
   */
  private getDefaultEnvironment() {
    return {
      nodeVersion: '20.3.0',
      buildTool: 'astro' as const,
      environmentVariables: {
        NODE_ENV: 'development',
      },
      workspaceMount: '/app',
      outputPath: '/app/dist',
      hmrEnabled: true,
      devServerPort: 4321,
    };
  }
}
